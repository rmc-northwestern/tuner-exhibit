{"ast":null,"code":"/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactElementValidator\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n'use strict';\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactFragment = require(\"./ReactFragment\");\n\nvar ReactPropTypeLocations = require(\"./ReactPropTypeLocations\");\n\nvar ReactPropTypeLocationNames = require(\"./ReactPropTypeLocationNames\");\n\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\n\nvar ReactNativeComponent = require(\"./ReactNativeComponent\");\n\nvar getIteratorFn = require(\"./getIteratorFn\");\n\nvar invariant = require(\"./invariant\");\n\nvar warning = require(\"./warning\");\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = ReactCurrentOwner.current.getName();\n\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\nvar loggedTypeFailures = {};\nvar NUMERIC_PROPERTY_REGEX = /^\\d+$/;\n/**\n * Gets the instance's name for use in warnings.\n *\n * @internal\n * @return {?string} Display name or undefined\n */\n\nfunction getName(instance) {\n  var publicInstance = instance && instance.getPublicInstance();\n\n  if (!publicInstance) {\n    return undefined;\n  }\n\n  var constructor = publicInstance.constructor;\n\n  if (!constructor) {\n    return undefined;\n  }\n\n  return constructor.displayName || constructor.name || undefined;\n}\n/**\n * Gets the current owner's displayName for use in warnings.\n *\n * @internal\n * @return {?string} Display name or undefined\n */\n\n\nfunction getCurrentOwnerDisplayName() {\n  var current = ReactCurrentOwner.current;\n  return current && getName(current) || undefined;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  warnAndMonitorForKeyUse('Each child in an array or iterator should have a unique \"key\" prop.', element, parentType);\n}\n/**\n * Warn if the key is being defined as an object property but has an incorrect\n * value.\n *\n * @internal\n * @param {string} name Property name of the key.\n * @param {ReactElement} element Component that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validatePropertyKey(name, element, parentType) {\n  if (!NUMERIC_PROPERTY_REGEX.test(name)) {\n    return;\n  }\n\n  warnAndMonitorForKeyUse('Child objects should have non-numeric keys so ordering is preserved.', element, parentType);\n}\n/**\n * Shared warning and monitoring code for the key warnings.\n *\n * @internal\n * @param {string} message The base warning that gets output.\n * @param {ReactElement} element Component that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction warnAndMonitorForKeyUse(message, element, parentType) {\n  var ownerName = getCurrentOwnerDisplayName();\n  var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n  var useName = ownerName || parentName;\n  var memoizer = ownerHasKeyUseWarning[message] || (ownerHasKeyUseWarning[message] = {});\n\n  if (memoizer.hasOwnProperty(useName)) {\n    return;\n  }\n\n  memoizer[useName] = true;\n  var parentOrOwnerAddendum = ownerName ? \" Check the render method of \" + ownerName + \".\" : parentName ? \" Check the React.render call using <\" + parentName + \">.\" : ''; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  var childOwnerAddendum = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Name of the component that originally created this child.\n    var childOwnerName = getName(element._owner);\n    childOwnerAddendum = \" It was passed a child from \" + childOwnerName + \".\";\n  }\n\n  \"production\" !== process.env.NODE_ENV ? warning(false, message + '%s%s See https://fb.me/react-warning-keys for more information.', parentOrOwnerAddendum, childOwnerAddendum) : null;\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n\n      if (ReactElement.isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (ReactElement.isValidElement(node)) {\n    // This element was passed in a valid location.\n    node._store.validated = true;\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node); // Entry iterators provide implicit keys.\n\n    if (iteratorFn) {\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n\n        while (!(step = iterator.next()).done) {\n          if (ReactElement.isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    } else if (typeof node === 'object') {\n      var fragment = ReactFragment.extractIfFragment(node);\n\n      for (var key in fragment) {\n        if (fragment.hasOwnProperty(key)) {\n          validatePropertyKey(key, fragment[key], parentType);\n        }\n      }\n    }\n  }\n}\n/**\n * Assert that the props are valid\n *\n * @param {string} componentName Name of the component for error messages.\n * @param {object} propTypes Map of prop name to a ReactPropType\n * @param {object} props\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @private\n */\n\n\nfunction checkPropTypes(componentName, propTypes, props, location) {\n  for (var propName in propTypes) {\n    if (propTypes.hasOwnProperty(propName)) {\n      var error; // Prop type validation may throw. In case they do, we don't want to\n      // fail the render phase where it didn't fail before. So we log it.\n      // After these have been cleaned up, we'll let them throw.\n\n      try {\n        // This is intentionally an invariant that gets caught. It's the same\n        // behavior as without this statement except with a better message.\n        \"production\" !== process.env.NODE_ENV ? invariant(typeof propTypes[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(typeof propTypes[propName] === 'function');\n        error = propTypes[propName](props, propName, componentName, location);\n      } catch (ex) {\n        error = ex;\n      }\n\n      if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n        // Only monitor this failure once because there tends to be a lot of the\n        // same error.\n        loggedTypeFailures[error.message] = true;\n        var addendum = getDeclarationErrorAddendum(this);\n        \"production\" !== process.env.NODE_ENV ? warning(false, 'Failed propType: %s%s', error.message, addendum) : null;\n      }\n    }\n  }\n}\n\nvar warnedPropsMutations = {};\n/**\n * Warn about mutating props when setting `propName` on `element`.\n *\n * @param {string} propName The string key within props that was set\n * @param {ReactElement} element\n */\n\nfunction warnForPropsMutation(propName, element) {\n  var type = element.type;\n  var elementName = typeof type === 'string' ? type : type.displayName;\n  var ownerName = element._owner ? element._owner.getPublicInstance().constructor.displayName : null;\n  var warningKey = propName + '|' + elementName + '|' + ownerName;\n\n  if (warnedPropsMutations.hasOwnProperty(warningKey)) {\n    return;\n  }\n\n  warnedPropsMutations[warningKey] = true;\n  var elementInfo = '';\n\n  if (elementName) {\n    elementInfo = ' <' + elementName + ' />';\n  }\n\n  var ownerInfo = '';\n\n  if (ownerName) {\n    ownerInfo = ' The element was created by ' + ownerName + '.';\n  }\n\n  \"production\" !== process.env.NODE_ENV ? warning(false, 'Don\\'t set .props.%s of the React component%s. Instead, specify the ' + 'correct value when initially creating the element or use ' + 'React.cloneElement to make a new element with updated props.%s', propName, elementInfo, ownerInfo) : null;\n} // Inline Object.is polyfill\n\n\nfunction is(a, b) {\n  if (a !== a) {\n    // NaN\n    return b !== b;\n  }\n\n  if (a === 0 && b === 0) {\n    // +-0\n    return 1 / a === 1 / b;\n  }\n\n  return a === b;\n}\n/**\n * Given an element, check if its props have been mutated since element\n * creation (or the last call to this function). In particular, check if any\n * new props have been added, which we can't directly catch by defining warning\n * properties on the props object.\n *\n * @param {ReactElement} element\n */\n\n\nfunction checkAndWarnForMutatedProps(element) {\n  if (!element._store) {\n    // Element was created using `new ReactElement` directly or with\n    // `ReactElement.createElement`; skip mutation checking\n    return;\n  }\n\n  var originalProps = element._store.originalProps;\n  var props = element.props;\n\n  for (var propName in props) {\n    if (props.hasOwnProperty(propName)) {\n      if (!originalProps.hasOwnProperty(propName) || !is(originalProps[propName], props[propName])) {\n        warnForPropsMutation(propName, element); // Copy over the new value so that the two props objects match again\n\n        originalProps[propName] = props[propName];\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  if (element.type == null) {\n    // This has already warned. Don't throw.\n    return;\n  } // Extract the component class from the element. Converts string types\n  // to a composite class which may have propTypes.\n  // TODO: Validating a string's propTypes is not decoupled from the\n  // rendering target which is problematic.\n\n\n  var componentClass = ReactNativeComponent.getComponentClassForElement(element);\n  var name = componentClass.displayName || componentClass.name;\n\n  if (componentClass.propTypes) {\n    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);\n  }\n\n  if (typeof componentClass.getDefaultProps === 'function') {\n    \"production\" !== process.env.NODE_ENV ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : null;\n  }\n}\n\nvar ReactElementValidator = {\n  checkAndWarnForMutatedProps: checkAndWarnForMutatedProps,\n  createElement: function (type, props, children) {\n    // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n    \"production\" !== process.env.NODE_ENV ? warning(type != null, 'React.createElement: type should not be null or undefined. It should ' + 'be a string (for DOM elements) or a ReactClass (for composite ' + 'components).') : null;\n    var element = ReactElement.createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    }\n\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    validatePropTypes(element);\n    return element;\n  },\n  createFactory: function (type) {\n    var validatedFactory = ReactElementValidator.createElement.bind(null, type); // Legacy hook TODO: Warn if this is accessed\n\n    validatedFactory.type = type;\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      try {\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function () {\n            \"production\" !== process.env.NODE_ENV ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : null;\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      } catch (x) {// IE will fail on defineProperty (es5-shim/sham too)\n      }\n    }\n\n    return validatedFactory;\n  },\n  cloneElement: function (element, props, children) {\n    var newElement = ReactElement.cloneElement.apply(this, arguments);\n\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], newElement.type);\n    }\n\n    validatePropTypes(newElement);\n    return newElement;\n  }\n};\nmodule.exports = ReactElementValidator;","map":null,"metadata":{},"sourceType":"script"}